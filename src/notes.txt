Setting up the PlatformIO project for the following hardware and software components:
    1. Sunton ESP32-8048S070 or Guition ESP32-8048S070
        a. Expressif ESP32-S3-WROOM-1 MCU Module, 240MHz, 512KB SRAM, 384KB ROM, 8M PSRAM, 16MB Flash 
        b. 800x480 7.0-inch TFT LCD RGB565 64K Color Display
        c. GT911 Capacitive Touch
    2. LovyanGFX 1.2.7 Display Driver with DMA feature
    3. LvGL 9.4.0 Graphics Library with Widgets Demo

Setup Procedure

1. Prepare workstation software:

1.1. Install Visual Studio Code IDE

1.2. Install PlatformIO VSCode Extension

1.3. Install the Espressif32 platform within PlatformIO

1.4. Copy the sunton_s3.json board profile into the espressif32 boards folder located (Win11) C:/Users/[user]/.platformio/platforms/espressif32/boards/

2. Prepare the PlatformIO Project

2.1 Create a new PlatformIO project using the "Sunton ESP32-S3" Board type and "Arduino" Framework

2.2 Save the VSCode workspace

2.3 Install the LvGL 9.4.0 Library within PlatformIO, or any later version below 10.0.0.

2.4 Install the Lovyan GFX 1.2.7 (or newer) Library within PlatformIO

3. Modify platformio.ini in the following ways:

3.1 set the serial port monitor speed to 115200:
    [env:sunton_s3]
    platform = espressif32
    board = sunton_s3
    framework = arduino
    monitor_speed = 115200

    lib_deps =
        lovyan03/LovyanGFX@^1.2.7
        lvgl/lvgl@^9.4.0

3.2. optional: enable GNU++17 C++ compiler, optimize output for size, and set ESP32 log level to INFO:
    [env:sunton_s3]
    platform = espressif32
    board = sunton_s3
    framework = arduino
    monitor_speed = 115200

    build_unflags = 
        -std=gnu++11
    build_flags = 
        -Os
        -std=gnu++17
        -DCORE_DEBUG_LEVEL=3

    lib_deps =
        lovyan03/LovyanGFX@^1.2.7
        lvgl/lvgl@^9.4.0

3.3. enable storing the lv_conf.h file in the project LIB folder, and protect it from being erased by a "Full Clean" operation:
    [env:sunton_s3]
    platform = espressif32
    board = sunton_s3
    framework = arduino
    monitor_speed = 115200

    build_unflags = 
        -std=gnu++11
    build_flags = 
        -Os
        -std=gnu++17
        -DCORE_DEBUG_LEVEL=3
        -DLV_CONF_INCLUDE_SIMPLE
        -I./lib

    lib_deps =
        lovyan03/LovyanGFX@^1.2.7
        lvgl/lvgl@^9.4.0

3.4 save changes to platformio.ini

4. Create and modify the lv_conf.h file in the following ways:

4.1 Copy the template file from LvGL library to project lib folder.  
    Copy from: .pio/libdeps/sunton_s3/lvgl/lv_conf_template.h and copy-rename to: lib/lv_conf.h
    Open lv_conf.h for editing.

4.2 enable its content by setting the first #if to 1
    #if 1 /*Set it to "1" to enable content*/

4.3 optional: increase the LV_MEM_SIZE to 1MB as future projects will use up the buffer at its default size:
    #define LV_MEM_SIZE (1024U * 1024U)

4.4 change the type of memory from which buffers are allocated to PSRAM:
    #if LV_MEM_ADR == 0
        #undef LV_MEM_POOL_INCLUDE
        #undef LV_MEM_POOL_ALLOC
        #define LV_MEM_POOL_INCLUDE     "esp_heap_caps.h"
        #define LV_MEM_POOL_ALLOC(size) heap_caps_malloc(size, MALLOC_CAP_SPIRAM)
    #endif

4.5 optional: enable the logging of messages in case something goes wrong:
    optional: enable system monitoring:
    optional: enable the performance monitor to show us CPU usage and FPS count:
    optional: enable memory monitor to show is LV_MEM_SIZE consumption of this and future projects:
    #define LV_USE_LOG 1
    #define LV_USE_SYSMON 1
    #define LV_USE_PERF_MONITOR 1
    #define LV_USE_MEM_MONITOR 1

5. enable and test serial monitoring of log messages.  modify the main.cpp file in the following ways:

5.1 clean up the default main.cpp content and prepare it for our changes to the setup() and loop() functions.  use ALT-Shift-F (CMD-Shift-F) to periodically reformat the content.
    #include <Arduino.h>

    void setup()
    {
      // put your setup code here, to run once:
    }

    void loop()
    {
      // put your main code here, to run repeatedly:
    }

5.2 modify setup() to prepare the Serial interface to write log messages:
    static const char *TAG = "main"; // logging

    void setup()
    {
      Serial.begin(115200);
      while (!Serial)
      {
        delay(100);
      }
      ESP_LOGI(TAG, "setup started.");
    }

5.3 test. compile and upload the firmware to our device.  open the PlatformIO Serial Monitor and observe the "setup started" message.  this is a good place to resolve any USB connection issues with our device, and any compiler or build errors.  on success, our serial monitor may look something like:
    --- Terminal on COM7 | 115200 8-N-1
    --- Available filters and text transformations: colorize, debug, default, direct, esp32_exception_decoder, hexlify, log2file, nocontrol, printable, send_on_enter, time
    --- More details at https://bit.ly/pio-monitor-filters
    --- Quit: Ctrl+C | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H
    ESP-ROM:esp32s3-20210327
    Build:Mar 27 2021
    rst:0x1 (POWERON),boot:0x8 (SPI_FAST_FLASH_BOOT)
    SPIWP:0xee
    mode:DIO, clock div:1
    load:0x3fce3808,len:0x4bc
    load:0x403c9700,len:0xbd8
    load:0x403cc700,len:0x2a0c
    entry 0x403c98d0
    [   105][I][esp32-hal-psram.c:96] psramInit(): PSRAM enabled
    [   126][I][main.cpp:12] setup(): [main] setup started.

6. setup and test the LovyanGFX driver for our device.  modify the main.cpp file in the following ways:

6.1 to the top of main.cpp, add the #includes of the lovyan driver:
    #include <LovyanGFX.hpp>
    #include <lgfx/v1/platforms/esp32s3/Panel_RGB.hpp>
    #include <lgfx/v1/platforms/esp32s3/Bus_RGB.hpp>
    #include <driver/i2c.h>

6.2 below the TAG variable, add the LGFX class declaration specific to the device:
    class LGFX : public lgfx::LGFX_Device
    {
    public:
      lgfx::Bus_RGB _bus_instance;
      lgfx::Panel_RGB _panel_instance;
      lgfx::Light_PWM _light_instance;
      lgfx::Touch_GT911 _touch_instance;

      LGFX(void)
      {
        {
          auto cfg = _panel_instance.config();

          cfg.memory_width = 800;
          cfg.memory_height = 480;
          cfg.panel_width = 800;
          cfg.panel_height = 480;

          cfg.offset_x = 0;
          cfg.offset_y = 0;

          _panel_instance.config(cfg);
        }

        {
          auto cfg = _panel_instance.config_detail();

          cfg.use_psram = 1;

          _panel_instance.config_detail(cfg);
        }

        {
          auto cfg = _bus_instance.config();
          cfg.panel = &_panel_instance;
          cfg.pin_d0 = GPIO_NUM_15;  // B0
          cfg.pin_d1 = GPIO_NUM_7;   // B1
          cfg.pin_d2 = GPIO_NUM_6;   // B2
          cfg.pin_d3 = GPIO_NUM_5;   // B3
          cfg.pin_d4 = GPIO_NUM_4;   // B4
          cfg.pin_d5 = GPIO_NUM_9;   // G0
          cfg.pin_d6 = GPIO_NUM_46;  // G1
          cfg.pin_d7 = GPIO_NUM_3;   // G2
          cfg.pin_d8 = GPIO_NUM_8;   // G3
          cfg.pin_d9 = GPIO_NUM_16;  // G4
          cfg.pin_d10 = GPIO_NUM_1;  // G5
          cfg.pin_d11 = GPIO_NUM_14; // R0
          cfg.pin_d12 = GPIO_NUM_21; // R1
          cfg.pin_d13 = GPIO_NUM_47; // R2
          cfg.pin_d14 = GPIO_NUM_48; // R3
          cfg.pin_d15 = GPIO_NUM_45; // R4

          cfg.pin_henable = GPIO_NUM_41;
          cfg.pin_vsync = GPIO_NUM_40;
          cfg.pin_hsync = GPIO_NUM_39;
          cfg.pin_pclk = GPIO_NUM_42;
          cfg.freq_write = 12000000; // reduce jitter

          cfg.hsync_polarity = 0;
          cfg.hsync_front_porch = 80;
          cfg.hsync_pulse_width = 4;
          cfg.hsync_back_porch = 16;
          cfg.vsync_polarity = 0;
          cfg.vsync_front_porch = 22;
          cfg.vsync_pulse_width = 4;
          cfg.vsync_back_porch = 4;
          cfg.pclk_idle_high = 1;
          _bus_instance.config(cfg);
        }
        _panel_instance.setBus(&_bus_instance);

        {
          auto cfg = _light_instance.config();
          cfg.pin_bl = GPIO_NUM_2;
          _light_instance.config(cfg);
        }
        _panel_instance.light(&_light_instance);

        {
          auto cfg = _touch_instance.config();
          cfg.x_min = 0;
          cfg.x_max = 800;
          cfg.y_min = 0;
          cfg.y_max = 480;
          cfg.pin_int = GPIO_NUM_NC;
          cfg.bus_shared = true;
          cfg.offset_rotation = 0;
          cfg.i2c_port = I2C_NUM_1;
          cfg.pin_sda = GPIO_NUM_19;
          cfg.pin_scl = GPIO_NUM_20;
          cfg.pin_rst = GPIO_NUM_38;
          cfg.freq = 400000;
          cfg.i2c_addr = 0x14; // 0x5D , 0x14
          _touch_instance.config(cfg);
          _panel_instance.setTouch(&_touch_instance);
        }

        setPanel(&_panel_instance);
      }
    };

6.3 below the LGFX class, use it to declare the gfx variable:
    LGFX gfx;

6.4 below the "setup started." log message within setup(), add the following lines to setup GFX and use of the display:
    ESP_LOGI(TAG, "starting LovyanGFX %d.%d.%d display...", LGFX_VERSION_MAJOR, LGFX_VERSION_MINOR, LGFX_VERSION_PATCH);
    gfx.begin();
    gfx.initDMA();
    gfx.setBrightness(128);           // adjust as desired (1-255)
    gfx.setCursor(0, 0);              // optional
    gfx.setTextColor(0xFFFF, 0x0000); // optional
    gfx.setTextSize(1);               // optional
    gfx.setTextWrap(false);           // optional
    ESP_LOGI(TAG, "display started.");

6.5 test display. below the "display started." log entry within setup(), add the following two lines of test code, compile and upload the firmware to our device.  we should observe three (3) changes, the log entry "display started" in the serial monitor, a red rectangle in the middle of the display, and the text "hello, world." in the upper left corner.  once tested, remove the two test lines of code from the bottom of setup().
    gfx.fillRect(200, 120, 400, 240, 0xF800);
    gfx.println("hello, world.");

6.6 test touch. within the loop() function, add the following lines of test code, compile and upload the firmware to our device.  as we touch the display, we should observe log entries in the serial monitor telling us the location of the touches.  once tested, remove these test lines of code from the loop() function.
    uint16_t touchX, touchY;
    bool touched = gfx.getTouch(&touchX, &touchY);
    if (touched)
    {
      ESP_LOGI(TAG, "display touched at: %d, %d.", touchX, touchY);
    }

7. setup use of the LvGL library with our display and touch panel.

7.1 to the top of main.cpp, add the #include of the LvGL library:
    #include <lvgl.h>

7.2 below the "gfx" variable declaration above setup(), add the following variables to define our display, touch and buffer configurations.
    #define _LV_DISP_DRAW_BUF_SIZE (gfx.width() * gfx.height() * sizeof(lv_color_t) / 8)
    lv_color_t *lv_buffer[2];
    lv_display_t *lv_display;
    lv_indev_t *lv_input;

7.3 declare the "buffer flush" callback used by LvGL to write content to the display.  above setup() add the following my_disp_flush() function:
    void my_disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map)
    {
      uint16_t *buf16 = (uint16_t *)px_map;
      if (gfx.getStartCount() == 0)
      {
        gfx.startWrite();
      }
      gfx.pushImageDMA(area->x1,
                      area->y1,
                      area->x2 - area->x1 + 1,
                      area->y2 - area->y1 + 1,
                      buf16);
      gfx.endWrite();
      lv_disp_flush_ready(disp);
    }

7.4 allocate the draw buffers, and initialize and register the display driver with LvGL.  add the following lines to the bottom of setup():
    ESP_LOGI(TAG, "starting LvGL %d.%d.%d gui...", LVGL_VERSION_MAJOR, LVGL_VERSION_MINOR, LVGL_VERSION_PATCH);
    lv_init();
    lv_buffer[0] = (lv_color_t *)heap_caps_aligned_alloc(64, _LV_DISP_DRAW_BUF_SIZE, /* MALLOC_CAP_DMA | */ MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    lv_buffer[1] = (lv_color_t *)heap_caps_aligned_alloc(64, _LV_DISP_DRAW_BUF_SIZE, /* MALLOC_CAP_DMA | */ MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (lv_buffer[0] == nullptr || lv_buffer[1] == nullptr)
    {
      ESP_LOGI(TAG, "buffer allocation failure, aborting.");
      while (1)
        yield();
    }
    lv_display = lv_display_create(gfx.width(), gfx.height());
    lv_display_set_color_format(lv_display, LV_COLOR_FORMAT_RGB565_SWAPPED);
    lv_display_set_flush_cb(lv_display, my_disp_flush);
    lv_display_set_buffers(lv_display, lv_buffer[0], lv_buffer[1], _LV_DISP_DRAW_BUF_SIZE, LV_DISPLAY_RENDER_MODE_PARTIAL);

7.5 declare the "touch read" callback used by LvGL to know when and where the display was touched.  above setup() add the following my_touchpad_read() function:
    void my_touchpad_read(lv_indev_t *indev, lv_indev_data_t *data)
    {
      uint16_t touchX, touchY;
      const uint32_t touchDebounce = 10; // ms
      static uint32_t lastTouchTime = 0;
      if (millis() - lastTouchTime < touchDebounce)
      {
        return;
      }

      bool touched = gfx.getTouch(&touchX, &touchY);
      data->state = LV_INDEV_STATE_RELEASED;

      if (touched)
      {
        lastTouchTime = millis();
        data->state = LV_INDEV_STATE_PRESSED;
        data->point.x = touchX;
        data->point.y = touchY;
      }
    }

7.6 initialize and register the input driver with LvGL.  add the following lines to the bottom of setup():
    lv_input = lv_indev_create();
    lv_indev_set_type(lv_input, LV_INDEV_TYPE_POINTER);
    lv_indev_set_read_cb(lv_input, my_touchpad_read);

7.7 declare the "clock tick" callback used by LvGL to know how much time has passed since the prior graphics operation.  without it, the UI will not update, no callbacks are made or touches processed.  above setup() add the following my_tick() function:
    uint32_t my_tick(void)
    {
      return millis();
    }

7.8 register the tick callback with LvGL.  add the following lines to the bottom of setup():
    lv_tick_set_cb(my_tick);

7.8 prepare the main loop() to drive LvGL and do its thing.  add the following lines to the loop() function:
    lv_timer_handler();

    delay(1);  

7.9 test LvGL function. add the following two lines of test code to the bottom of setup(), compile and upload the firmware to our device.  we should observe the slider centered in the display, the knob should slide left and right when touched and dragged accordingly.  once tested, remove the two test lines of code from the bottom of setup().
    lv_obj_t *slider = lv_slider_create(lv_scr_act());
    lv_obj_align(slider, LV_ALIGN_CENTER, 0, 0);

8. prepare the widgets demo as the screen content.  these steps are unnecessary if our project does not use the widgets demo.

8.1 modify lv_conf.h and enable the LvGL widgets demo as our example display content:
    #define LV_USE_DEMO_WIDGETS 1

8.2 to the top of main.cpp, add the #include of the LvGL widgets demo:
    #include <demos/lv_demos.h>

8.3 as of this writing, when using LvGL 9.4.0, the demos folder containing the widgets demo must be copied in order for it to be compiled and correctly linked to the firmware binary.  copy the whole "demos" folder from: .pio/libdeps/sunton_s3/lvgl/demos into the "src" folder: .pio/libdeps/sunton_s3/lvgl/src such that when complete, there is a copy of the demos folder at: .pio/libdeps/sunton_s3/lvgl/src/demos 

8.4 modify the #include directives in the .pio/libdeps/sunton_s3/lvgl/src/demos/widgets/lv_demo_widgets.h file and correct the path of the following two lines:
    #include "../src/draw/lv_draw.h"
    #include "../src/draw/lv_draw_triangle.h"

8.5 modify main.cpp to draw the demo content.  add the following lines to the botton of setup():
    lv_demo_widgets();
    ESP_LOGI(TAG, "gui started.");

8.6 test widgets demo. compile and upload the firmware to our device.  we should observe the "gui started" message in the serial monitor and a rich demo of widgets on the display.

Also, be aware platformio may update the libdeps (library dependencies) from time to time, and when it does, it may remove the copied demos folder.
When building, if we get the error "undefined reference to `lv_demo_widgets'" we may need to repeat these changes made to the LvGL library.




